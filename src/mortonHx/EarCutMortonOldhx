package mortonHx;
import mortonHx.Morton2D;
import mortonHx.PointHit;
import mortonHx.SortableArray;
class EarCuttingMorton {
    var pointHit: IHitInt;
    var points: Array<{x:Int,y:Int}>;
    var sortableArr: SortableArray<Morton2D>;
    // default is to assume test data is 0 to 800 as that is what I have to hand, and never negative.
    public inline static function fromArrayFloat(arr:Array<Float>, scale: Float = 32767/800, pointHit: IHitInt = null){
        var k: Int;
        var p = new Array<{x:Int,y:Int}>();
        for( i in 0...Math.ceil(arr.length/2) ){
            var k = Std.int(i*2);
            p[i] = {x:Std.int(arr[i]*scale),y:Std.int(arr[i+1]*scale)};
        }
        return new EarCuttingMorton( p, pointHit );
    }
    public function new( points: Array<{x:Int, y:Int}>, pointHit: IHitInt = null ) {
        this.pointHit = ( pointHit == null ) ? new EdgeFunctionHitInt() : pointHit;
        // Normalize winding to CCW
        if (!isCounterClockwise(points)) {
            points.reverse();
        }
        this.points = points;
        this.sortableArr = (cast points: Array<Morton2D>);
    }
    
    /**
     * Uses the Shoelace Formula to determine winding.
     * Returns true if CCW, false if CW.
     */
    static function isCounterClockwise(p: Array<{x:Int, y:Int}>): Bool {
        var area: Float = 0;
        for (i in 0...p.length) {
            var j = (i + 1) % p.length;
            // Signed area sum: (x1*y2 - x2*y1)
            area += (cast(p[i].x, Float) * p[j].y) - (cast(p[j].x, Float) * p[i].y);
        }
        // If area > 0, it's CCW. If area < 0, it's CW.
        return area > 0;
    }
    public inline function setTriangle( ax: Int, ay: Int, bx: Int, by: Int, cx: Int, cy: Int ){
        pointHit.prepare( ax, ay, bx, by, cx, cy );
    }
    public static function isInRange(pCode:Int, v1Code:Int, minCode:Int, maxCode:Int):Bool {
        // 2. Determine the bits that differ between the extreme vertices
        // A Morton range is a quadtree node if the shared prefix is the same
        var diff = minCode ^ maxCode;
        if (diff == 0) return pCode == v1Code;
        // 3. Find MSB without Math.log
        // This bit-smearing technique is faster than Math.log on all Haxe targets
        var v = diff;
        v |= v >> 1;
        v |= v >> 2;
        v |= v >> 4;
        v |= v >> 8;
        v |= v >> 16;
        // Create a mask that keeps the prefix shared by the triangle
        // (v + 1) is the next power of 2; we invert it for the mask
        var mask = ~(v);
        // 4. Check if pCode shares the same prefix as the triangle's cell
        return (pCode & mask) == (v1Code & mask);
    }
    public function pointsInTriangle( ax: Int, ay: Int, bx: Int, by: Int, cx:Int, cy: Int ): Bool {
        setTriangle(ax,ay,bx,by,cx,cy);
        var v1Code  = new Morton2D( ax, ay );
        var v2Code  = new Morton2D( bx, by );
        var v3Code  = new Morton2D( cx, cy );
        var minCode = Morton2D.min3i(v1Code, v2Code, v3Code));
        var maxCode = Morton2D.max3i(v1Code, v2Code, v3Code));
        var start   = Morton2D.findStartIndex( minCode );
        var end     = Morton2D.findEndIndex( maxCode );
        for( i in start...end ){
            final p = this[i];
            if( !isInRange( p, v1Code, minCode, maxCode ) ) return continue;
            if( p == v1Code || p == v2Code || p == v3Code ) return continue;// ignore if points are the triangle! Needs considering..
            final decode = (p: Morton2D).decode();
            final x = decode.x;
            final y = decode.y;
            if( pointHit.checkHit( x, y ) ) return true;
        }
        return false;
    }
    public static inline function isConvexFloat(ax:Int, ay:Int, bx:Int, by:Int, cx:Int, cy:Int):Bool {
        // JS numbers are 64-bit floats by default; this calculation is precise
        // for coordinates up to ~67 million.
        var val:Float = (cast(bx - ax, Float) * (cy - by)) - (cast(by - ay, Float) * (cx - bx));
        return val > 0;
    }

    public function createLinkedList(): Array<EarNode> {
        var list = [for (p in points) {
            var n:EarNode = { x:p.x, y:p.y, m:new Morton2D(p.x, p.y).toInt(), prev:null, next:null, isReflex:false };
            n;
        }];
        for (i in 0...list.length) {
            list[i].next = list[(i + 1) % list.length];
            list[i].prev = list[(i + list.length - 1) % list.length];
        }
        return list;
    }
    
    public inline function isValidEar( ear: EarNode ): Bool {
        if (ear.isReflex) return false; // Ear tip must be convex
        var a = ear.prev;
        var b = ear;
        var c = ear.next;
        return !pointsInTriangle( a.x, a.y, b.x, b.y, c.x, c.y );
    }
    public function triangulate():Array<Int> {
        var nodes: Array<EarNode> = createLinkedList();
        var indices = [];
        var current = nodes[0];
        var count = nodes.length;

        // 1. Initial Pass: Mark all Reflex vertices
        var start = current;
        do {
            start.isReflex = !isConvexFloat(start.prev.x, start.prev.y, start.x, start.y, start.next.x, start.next.y);
            start = start.next;
        } while (start != current);

        // 2. Main Ear-Clipping Loop
        var stop = current;
        while (count > 3) {
            var prev = current.prev;
            var next = current.next;

            if (isValidEar(current)) {
                // CLIP EAR
                indices.push(prev.x); // Or push an ID/Index
                indices.push(current.x);
                indices.push(next.x);

                // Remove current from list
                prev.next = next;
                next.prev = prev;
                
                // Only update reflex status for neighbors
                prev.isReflex = !isConvexFloat(prev.prev.x, prev.prev.y, prev.x, prev.y, prev.next.x, prev.next.y);
                next.isReflex = !isConvexFloat(next.prev.x, next.next.y, next.x, next.y, next.next.x, next.next.y);

                current = next;
                stop = next;
                count--;
                continue;
            } else {
                current = next;
                if (current == stop) {
                    trace("No more valid ears found; triangulation incomplete.");
                    break; // Failure: likely self-intersecting polygon
                }
            }
        }
        // Add the final remaining triangle
        if (count == 3) {
            indices.push(current.prev.x); indices.push(current.prev.y);
            indices.push(current.x);      indices.push(current.y);
            indices.push(current.next.x); indices.push(current.next.y);
        }
        return indices;
    }
}






    /*
    public inline function minTriMorton2D( ax: Int, bx: Int, cx: Int
                                         , ay: Int, by: Int, cy: Int ): Morton2D {
        return ( { x: min2i( ax, bx, cx ), y: min2i( ay, by, cy ) }: Morton2D );
    }
    public inline function maxTriMorton2D( ax: Int, bx: Int, cx: Int
                                         , ay: Int, by: Int, cy: Int ): Morton2D {
        return ( { x: min2i( ax, bx, cx ), y: min2i( ay, by, cy ) }: Morton2D );
    }
    var min: Morton2D;
    var max: Morton2D;
    public inline function AABB( ax, ay, bx, by, cx, cy ){
        // Find AABB range to establish search targets in 1D Morton space
        final minX = minI(ax, minI(bx, cx))
        final maxX2 = Math.maxI(ax, Math.maxI(bx, cx));
        final minY = Math.minI(ay, Math.minI(by, cy))
        final maxY2 = Math.maxI(ay, Math.maxI(by, cy));
        min = { x: minX2, y: minY2 };
        max = { x: maxX2, y: maxY2 };
    }
    */
    /*
    public static function isInRange(pCode:Int, v1Code:Int, v2Code:Int, v3Code:Int):Bool {
        // 1. Efficiently find the range of the triangle's Morton codes
        // Use your custom minI/maxI to avoid Math.min (which returns Floats)
        var minCode = minI(v1Code, minI(v2Code, v3Code));
        var maxCode = maxI(v1Code, maxI(v2Code, v3Code));
        // 2. Determine the bits that differ between the extreme vertices
        // A Morton range is a quadtree node if the shared prefix is the same
        var diff = minCode ^ maxCode;
        if (diff == 0) return pCode == v1Code;
        // 3. Find MSB without Math.log
        // This bit-smearing technique is faster than Math.log on all Haxe targets
        var v = diff;
        v |= v >> 1;
        v |= v >> 2;
        v |= v >> 4;
        v |= v >> 8;
        v |= v >> 16;
        // Create a mask that keeps the prefix shared by the triangle
        // (v + 1) is the next power of 2; we invert it for the mask
        var mask = ~(v);
        // 4. Check if pCode shares the same prefix as the triangle's cell
        return (pCode & mask) == (v1Code & mask);
    }
    */